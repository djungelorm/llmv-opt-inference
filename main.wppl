// Test cases are the values of %0..%n
var exampleTests = [
  {'inputs': [1, 2, 3], 'output': 6},
  {'inputs': [1, 2, 4], 'output': 7},
  {'inputs': [1, 2, 5], 'output': 8}
];

// return %1+%2+%3
var exampleProgram = llvm.program(3, [llvm.instr(4, 'add', 1, 2), llvm.instr(0, 'add', 4, 3)]);

// Given a program, returns a modified program.
var modifyProgram = function(program) {
  if (flip(0.1))
    return program;
  //var transformation = uniformDraw([0,1,2,3,4]);
  //if (transformation == 0)
  {
    var idx = randomInteger(program.instrs.length);
    return modifyProgram(flipOperands(program, idx));
  }
};

var flipOperands = function(program, idx) {
  // Flip operands for a given instruction
  var instr = llvm.getInstr(program, idx);
  var newInstr = {'opcode': instr.opcode, 'result': instr.result, 'operands': [instr.operands[1], instr.operands[0]]};
  return llvm.replaceInstr(program, idx, newInstr);
};

// Given a program, return an estimate of its performance. Lower is better.
// TODO: make this better by attaching a predicted "latency" for each instruction
var performance = function(program) {
  return program.instrs.length;
};

// Given a program and a set of test cases, return an estimate of its correctness. Lower is better.
var correctness = function(programA, programB, tests) {
  var resultsA = llvm.runTests(programA, tests);
  var resultsB = llvm.runTests(programB, tests);
  return map2(function(a, b) { return Math.abs(a - b); }, resultsA, resultsB);
};

correctness(exampleProgram, flipOperands(exampleProgram, 1), exampleTests);
//console.log(compile_instrs(example_program.instrs));
//compile_instrs(flip_operands(example_program, 1).instrs);
