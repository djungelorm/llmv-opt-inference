var fs = require('fs');
var crypto = require('crypto');
var child_process = require('child_process');

var executableCache = {};
var executableCachePath = 'cache/program';

var runTests = function(program, tests) {
  var results = [];
  var exe = compileExecutable(program);
  if (exe == undefined)
    return undefined;
  for (var i = 0; i < tests.length; i++) {
    var inputs = tests[i].inputs;
    try {
      var stdout = child_process.execSync('./'+exe+' '+inputs.join(' '));
      results.push(parseInt(stdout.toString()));
    } catch (exn) {
      return undefined;
    }
  }
  return results;
};

var run = function(program, inputs) {
  var exe = compileExecutable(program);
  if (exe == undefined)
    return undefined;
  var stdout = child_process.execSync('./'+exe+' '+inputs.join(' '));
  return parseInt(stdout.toString());
};

var fileExists = function(path) {
  try {
    fs.accessSync(path);
    return true;
  } catch (exn) {
    return false;
  }
};

var compileExecutable = function(program) {
  var key = crypto.createHash('sha256').update(compileInstrs(program)).digest('hex');
  var path = executableCachePath+'-'+key;
  var irPath = path+'.ll';
  var exePath = path+'.exe';

  // If exists in in-memory cache
  if (key in executableCache) {
    //console.log('mem cache hit');
    return executableCache[key];
  }

  // If exists in disk cache
  if (fileExists(irPath)) {
    executableCache[key] = fileExists(exePath) ? exePath : undefined;
    //console.log('disk cache hit ', executableCache[key]);
    return executableCache[key];
  }

  //console.log('compiling...', key);

  // Compile the program
  var ir = compileIR(program);
  fs.writeFileSync(irPath, ir);
  try {
    child_process.execSync('llc -O0 -filetype obj -o '+path+'.o '+irPath);
  } catch (exn) {
    executableCache[key] = undefined;
    return undefined;
  }
  child_process.execSync('gcc -O0 '+path+'.o -o '+exePath);

  // Add to in-memory cache
  executableCache[key] = exePath;
  return exePath;
};

var compileIR = function(program) {
  var inputs = [];
  var inputsExtract = [];
  for (var idx = 1; idx < program.inputs+1; idx++) {
    inputs.push("i32 %r"+idx);
    inputsExtract.push(
      '  %r'+idx+'.ptr = getelementptr inbounds i8*, i8** %argc, i64 '+idx+'\n' +
      '  %r'+idx+'.str = load i8*, i8** %r'+idx+'.ptr\n' +
      '  %r'+idx+' = call i32 @atoi(i8* %r'+idx+'.str)');
  }
  inputs = inputs.join(', ');
  return [
    '; ModuleID = \'program\'', '',
    'declare i32 @atoi(i8*)', '',
    'declare i32 @printf(i8*, ...)', '',
    '@.str = private unnamed_addr constant [2 x i8] c"%d", align 1', '',
    'define i32 @main(i32 %argv, i8** %argc) {',
    'body:']
    .concat(inputsExtract)
    .concat(
      '  %r0 = call i32 @program('+inputs+')',
      '  %ignore = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0), i32 %r0)',
      '  ret i32 0',
      '}','')
    .concat(compileProgram(program))
    .join('\n');
};

var compileProgram = function(program) {
  var inputs = [];
  for (var idx = 1; idx < program.inputs+1; idx++)
    inputs.push('i32 %r'+idx);
  var instrs = compileInstrs(program);
  return ['define i32 @program(' + inputs.join(', ') + ') {', 'body:']
        .concat(instrs)
        .concat('}', '');
};

var ssaTransform = function(inputs, instrs) {
  var map = {};
  for (var i = 1; i < inputs+1; i++)
    map['%r'+i] = 0;
  var newInstrs = [];
  for (var i = 0; i < instrs.length; i++) {
    var instr = instrs[i];
    var result = instr.result;
    var operands = instr.operands;

    for (var j = 0; j < operands.length; j++) {
      var operand = operands[j];
      if (operand[0] == '%') {
        if (operand in map && map[operand] > 0) {
          operands[j] = operand+'.'+map[operand];
        } else {
          operands[j] = operand;
        }
      }
    }

    if (result) {
      if (result in map) {
        map[result] += 1;
        result = result+'.'+map[result];
      } else {
        map[result] = 0;
        result = result;
      }
    }

    newInstrs.push(llvm.instr(
      result,
      instr.opcode,
      operands
    ));
  }
  return newInstrs;
};

var compileInstrs = function(program) {
  var instrs = ssaTransform(program.inputs,
                            program.instrs.concat(llvm.instr(undefined, 'ret', ['%r0'])));
  var code = [];
  for (var idx = 0; idx < instrs.length; idx++)
    code.push(compileInstr(instrs[idx]));
  return code.join('\n');
};

var compileInstr = function(instr) {
  if (instr.result)
    return '  '+instr.result+' = '+instr.opcode+' i32 '+instr.operands.join(', ');
  else
    return '  '+instr.opcode+' i32 '+instr.operands.join(', ');
};

var createProgram = function(inputs, instrs) {
  return {'inputs': inputs, 'instrs': instrs};
};

var createInstr = function(result, opcode, operands) {
  return {'result': result, 'opcode': opcode, 'operands': operands};
};

var getInstr = function(program, idx) {
  return program.instrs[idx];
};

var changeInstr = function(program, idx, newInstr) {
  if (idx == 0) {
    var last = program.instrs.slice(idx+1);
    var newInstrs = [newInstr].concat(last);
  } else if (idx == program.instrs.length-1) {
    var first = program.instrs.slice(0,idx);
    var newInstrs = first.concat(newInstr);
  } else {
    var first = program.instrs.slice(0,idx);
    var last = program.instrs.slice(idx+1);
    var newInstrs = first.concat(newInstr).concat(last);
  }
  return createProgram(program.inputs, newInstrs);
};

var addInstr = function(program, idx, newInstr) {
  if (idx == 0) {
    var newInstrs = [newInstr].concat(program.instrs);
  } else if (idx == program.instrs.length) {
    var newInstrs = program.instrs.concat(newInstr);
  } else {
    var first = program.instrs.slice(0,idx);
    var last = program.instrs.slice(idx);
    var newInstrs = first.concat(newInstr).concat(last);
  }
  return createProgram(program.inputs, newInstrs);
};

var removeInstr = function(program, idx) {
  if (idx == 0) {
    var newInstrs = program.instrs.slice(idx+1);
  } else if (idx == program.instrs.length-1) {
    var newInstrs = program.instrs.slice(0,idx);
  } else {
    var first = program.instrs.slice(0,idx);
    var last = program.instrs.slice(idx+1);
    var newInstrs = first.concat(last);
  }
  return createProgram(program.inputs, newInstrs);
};

module.exports = {
  program: createProgram,
  instr: createInstr,
  getInstr: getInstr,
  changeInstr: changeInstr,
  addInstr: addInstr,
  removeInstr: removeInstr,
  runTests: runTests,
  run: run,
  compileExecutable: compileExecutable,
  compileIR: compileIR,
  compileInstrs: compileInstrs
};
